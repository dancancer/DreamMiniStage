# Slash Command Migration Plan

## 目标
- 复用 SillyTavern 的语法/执行抽象（解析器、链式作用域、生成器执行），但命令动作全部适配到本项目的服务与状态模型。
- 先确保当前已实现命令的行为保持一致，再按优先级逐步扩展，全过程配套测试。
- 保持代码品味：小函数、少分支、模块化，避免引入旧系统的全局耦合与深缩进。

## 高层工作分块（先粗后细）
1) 解析/执行内核重建
   - 递归下降解析 + AST 结构，支持闭包 `{: ... :}`、条件/循环语法。
   - 链式作用域模型（局部/全局/块级），支持变量查找冒泡、`/return`、`/break`/`/abort` 语义。
   - 生成器式执行器，支撑暂停/恢复/中断；明确错误边界与调试 hook。
   - 验证：独立 Vitest 覆盖解析、作用域、控制流、暂停/恢复。

2) 命令适配层（当前功能优先）
   - 定义 Command Descriptor（名称/别名/参数规范/handler），与解析/执行解耦。
   - 先重写并适配已实现命令：`/send`、`/trigger`、`/setvar`、`/getvar`、`/delvar`、`/echo`、`/pass`，仅调用本项目的 chat/变量服务。
   - 验证：handler 单测（mock 服务），确保现有行为无回归。

3) 增量命令落地（按 P0→P1→P2）
   - P0：`/if`、`/while`/`/times`、`/let|/var`、`/return`、闭包 `{: ... :}`。
   - P1：消息增强 `/sendas`、`/sys`、`/impersonate`、`/continue`、`/swipe`。
   - P2：基础数学/字符串/数组操作（`/add`、`/sub`、`/len`、`/trim`、`/push` 等）。
   - 每组先设计契约（状态/副作用/错误语义），再实现 + 单测。

4) 集成与回归防护
   - 与现有 chat 管线对接（触发生成、变量存取、副作用隔离），避免 UI/持久化耦合。
   - Lint/Test 门禁：`pnpm lint`、`pnpm test`；必要时加回归样例（脚本 -> 输出快照）。
   - 迭代留档：每完成一块更新本目录文档，记录验证结果与已知风险。

## 关键风险与决策点
- License：确认 SillyTavern 代码许可证（若为 AGPL/GPL，需重写等价逻辑而非直接拷贝）。
- 状态模型差异：SillyTavern 依赖多层全局/界面状态，本项目需以服务接口替代，避免引入全局单例。
- 复杂度控制：模块拆分避免大文件/深嵌套，保持可测与可维护。

## 交付节奏（初稿）
- M1：解析/执行内核 + 已有命令适配 + 基础测试。
- M2：P0 控制流/变量扩展 + 作用域/闭包测试齐备。
- M3：P1 消息增强命令 + 集成验证。
- M4：P2 算子/字符串/数组命令；视进度规划后续 P3。

## 后续细化方式
- 开始某一工作块时，再拆成可执行子任务（设计→实现→测试→验证），完成后更新本目录文档并补充测试结果。
- 运行原则：关注上下文窗口占用，超过 50% 时立即输出一次当前任务总结，保存为可续作的上下文文档，并提醒用户新开会话继续。
- 阶段性进展：见 `docs/slash-command-plan/CONTEXT.md`（包含内核/P0/P1完成情况与 backlog）。
